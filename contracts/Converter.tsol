pragma ever-solidity >= 0.71.0;

import "./interfaces/ITokenWallet.tsol";

///////////////
// Constants //
///////////////
uint128 constant MAXIMUM_RECEIVERS = 16;
uint128 constant SHARE_100_PERCENT = 1e9;
uint128 constant RATIO_ONE_TO_ONE = 1e9;

////////////
// Errors //
////////////
uint16 constant ONLY_OWNER_ERROR = 101;
uint16 constant INVALID_RECEIVERS_TOTAL_SHARE_ERROR = 102;
uint16 constant TOO_MUCH_RECEIVERS_ERROR = 103;
uint16 constant TOO_SMALL_DEPOSIT_ERROR = 104;

////////////////////
// Transfer flags //
////////////////////
uint8 constant TRANSFER_ALL_REMAINING_BALANCE = 128;
uint8 constant DESTROY_IF_BALANCE_IS_ZERO = 32;

////////////////
// Structures //
////////////////
struct Receiver {
    address wallet;

    /**
     * 1_000_000_000 means 100% of received COINs will be sent to the wallet
     *   500_000_000 means 50%  of received COINs will be sent to the wallet
     *   100_000_000 means 10%  of received COINs will be sent to the wallet
     */
    uint32 share;
}

/**
 * Converts COINs into TOKENs and distributes COINs between RECEIVERs.
 *
 * Legend
 *   COIN     - native blockchain coin e.g. EVER
 *   TOKEN    - TIP3 token implementation https://github.com/broxus/tip3
 *   RECEIVER - Contract address to which part of the deposited COINs is received
 *
 * TIP3 standard
 *   https://github.com/everscale-org/docs/blob/main/src/standard/TIP-3/1.md
 *   https://github.com/everscale-org/docs/blob/main/src/standard/TIP-3/2.md
 *
 * Gas
 *   Gas for TOKENs transfer and sending COINs to RECEIVERs is taken from customer message
 */
contract Converter {
    ///////////////
    // Modifiers //
    ///////////////
    modifier accept {
        tvm.accept();
        _;
    }

    modifier onlyOwner {
        require(_owner == msg.sender, ONLY_OWNER_ERROR);
        _;
    }

    modifier reserveBalance (uint128 balance, address recipient) {
        tvm.rawReserve(balance, 2);
        _;
        recipient.transfer(0, false, TRANSFER_ALL_REMAINING_BALANCE);
    }

    modifier giveChange () {
        tvm.rawReserve(address(this).balance - msg.value, 2);
        _;
        msg.sender.transfer(0, false, TRANSFER_ALL_REMAINING_BALANCE);
    }

    modifier receiversIsValid(Receiver[] receivers) {
        require(receivers.length <= MAXIMUM_RECEIVERS, TOO_MUCH_RECEIVERS_ERROR);
        uint64 total;
        for (uint8 i; i < receivers.length; i++)
            total += receivers[i].share;
        require(total == SHARE_100_PERCENT, INVALID_RECEIVERS_TOTAL_SHARE_ERROR);
        _;
    }

    modifier depositIsEnough(uint128 value) {
        require(value >= _minDeposit, TOO_SMALL_DEPOSIT_ERROR);
        _;
    }

    ///////////////
    // Variables //
    ///////////////
    address private _owner;
    Receiver[] private _receivers;
    address private _wallet;
    uint128 private _minDeposit;
    uint128 private _coinsTransferGas;
    uint128 private _tokensTransferGas;
    uint128 private _tokenWalletDeployGas;

    /**
     * 2_000_000_000 means 2   COINS for 1 TOKEN
     * 1_000_000_000 means 1   COINS for 1 TOKEN
     *   500_000_000 means 0.5 COINS for 1 TOKEN
     */
    uint128 private _ratio;

    /////////////////
    // Constructor //
    /////////////////
    constructor(
        address owner,
        Receiver[] receivers,
        address wallet,
        uint128 minDeposit,
        uint128 coinsTransferGas,
        uint128 tokensTransferGas,
        uint128 tokenWalletDeployGas,
        uint128 ratio,
        uint128 balance,
        address recipient
    ) accept reserveBalance(balance, recipient) receiversIsValid(receivers) {
        _owner = owner;
        _receivers = receivers;
        _wallet = wallet;
        _minDeposit = minDeposit;
        _coinsTransferGas = coinsTransferGas;
        _tokensTransferGas = tokensTransferGas;
        _tokenWalletDeployGas = tokenWalletDeployGas;
        _ratio = ratio;
    }

    //////////////
    // External //
    //////////////
    function convert() public view depositIsEnough(msg.value) {
        uint128 coinsTransferValue = gasToValue(_coinsTransferGas * MAXIMUM_RECEIVERS);
        uint128 tokenTransferValue = gasToValue(_tokensTransferGas);
        uint128 tokenWalletDeployValue = gasToValue(_tokenWalletDeployGas);
        uint128 availableCoins = address(this).balance - coinsTransferValue - tokenTransferValue - tokenWalletDeployValue;

        for (uint8 i = 0; i < _receivers.length; i++) {
            Receiver receiver = _receivers[i];
            uint128 value = math.muldiv(availableCoins, receiver.share, SHARE_100_PERCENT);
            receiver.wallet.transfer(value, false, 1);
        }

        uint128 amount = math.muldiv(msg.value, RATIO_ONE_TO_ONE, _ratio);
        ITokenWallet(_wallet).transfer{ value: tokenTransferValue, flag: 0, bounce: true }(
            amount,
            msg.sender,
            tokenWalletDeployValue,
            address(this),
            false,
            TvmCell()
        );
    }

    ////////////////////////////
    // External // Only owner //
    ////////////////////////////
    function setOwner(address owner) public onlyOwner giveChange {
        _owner = owner;
    }

    function setRatio(uint128 ratio) public onlyOwner giveChange {
        _ratio = ratio;
    }

    function setReceivers(Receiver[] receivers) public onlyOwner giveChange receiversIsValid(receivers) {
        _receivers = receivers;
    }

    function setWallet(address wallet) public onlyOwner giveChange {
        _wallet = wallet;
    }

    function setMinDeposit(uint128 minDeposit) public onlyOwner giveChange {
        _minDeposit = minDeposit;
    }

    function setCoinsTransferGas(uint128 coinsTransferGas) public onlyOwner giveChange {
        _coinsTransferGas = coinsTransferGas;
    }

    function setTokensTransferGas(uint128 tokensTransferGas) public onlyOwner giveChange {
        _tokensTransferGas = tokensTransferGas;
    }

    function setTokenWalletDeployGas(uint128 tokenWalletDeployGas) public onlyOwner giveChange {
        _tokenWalletDeployGas = tokenWalletDeployGas;
    }

    function terminate(address destination) public view onlyOwner {
        destination.transfer(0, false, TRANSFER_ALL_REMAINING_BALANCE + DESTROY_IF_BALANCE_IS_ZERO);
    }

    /////////////
    // Getters //
    /////////////
    function info() public view returns (
        address owner,
        Receiver[] receivers,
        address wallet,
        uint128 minDeposit,
        uint128 coinsTransferGas,
        uint128 tokensTransferGas,
        uint128 tokenWalletDeployGas,
        uint128 ratio
    ) {
        return (
            _owner,
            _receivers,
            _wallet,
            _minDeposit,
            _coinsTransferGas,
            _tokensTransferGas,
            _tokenWalletDeployGas,
            _ratio
        );
    }
}
