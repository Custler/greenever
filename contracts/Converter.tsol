pragma ever-solidity >= 0.71.0;

import "./interfaces/ITokenWallet.tsol";

///////////////
// Constants //
///////////////
uint128 constant MAXIMUM_RECEIVERS = 16;
uint128 constant SHARE_100_PERCENT = 1e9;
uint128 constant RATIO_ONE_TO_ONE = 1e9;

////////////
// Errors //
////////////
uint16 constant ONLY_OWNER_ERROR = 101;
uint16 constant INVALID_RECEIVERS_TOTAL_SHARE_ERROR = 102;
uint16 constant TOO_MUCH_RECEIVERS_ERROR = 103;

////////////////////
// Transfer flags //
////////////////////
uint8 constant TRANSFER_ALL_REMAINING_BALANCE = 128;
uint8 constant DESTROY_IF_BALANCE_IS_ZERO = 32;

////////////////
// Structures //
////////////////
struct Receiver {
    address wallet;

    /**
     * 1_000_000_000 means 100% of received COINs will be sent to the wallet
     *   500_000_000 means 50%  of received COINs will be sent to the wallet
     *   100_000_000 means 10%  of received COINs will be sent to the wallet
     */
    uint32 share;
}

/**
 * Convert COINs to TOKENs and send COINs to receivers
 *
 * Legend
 *   COIN  - native blockchain coin e.g. EVER
 *   TOKEN - TIP3 token implementation https://github.com/broxus/tip3
 *
 * TIP3 standard
 *   https://github.com/everscale-org/docs/blob/main/src/standard/TIP-3/1.md
 *   https://github.com/everscale-org/docs/blob/main/src/standard/TIP-3/2.md
 */
contract Converter {
    ///////////////
    // Modifiers //
    ///////////////
    modifier accept {
        tvm.accept();
        _;
    }

    modifier onlyOwner {
        require(_owner == msg.sender, ONLY_OWNER_ERROR);
        _;
    }

    modifier reserveBalance (uint128 balance, address recipient) {
        tvm.rawReserve(balance, 2);
        _;
        recipient.transfer(0, false, TRANSFER_ALL_REMAINING_BALANCE);
    }

    modifier giveChange () {
        tvm.rawReserve(address(this).balance - msg.value, 2);
        _;
        msg.sender.transfer(0, false, TRANSFER_ALL_REMAINING_BALANCE);
    }

    modifier receiversIsValid(Receiver[] receivers) {
        require(receivers.length <= MAXIMUM_RECEIVERS, TOO_MUCH_RECEIVERS_ERROR);
        uint64 total;
        for (uint8 i; i < receivers.length; i++)
            total += receivers[i].share;
        require(total == SHARE_100_PERCENT, INVALID_RECEIVERS_TOTAL_SHARE_ERROR);
        _;
    }

    ///////////////
    // Variables //
    ///////////////
    address private _owner;
    Receiver[] private _receivers;
    address private _wallet;

    /**
     * Minimum customer deposit in COINs
     *
     * Money for TOKENs transfer and sending COINs to recipients is taken from money that the customer sends
     * If you allow the user to send any value, then he can send small amount of money
     * A small amount of money may not be enough for TOKENs transfer and sending COINs to recipients
     * This is why the min Deposit variable is used
     */
    uint128 private _minDeposit;

    /**
     * 2_000_000_000 means 2   COINS for 1 TOKEN
     * 1_000_000_000 means 1   COINS for 1 TOKEN
     *   500_000_000 means 0.5 COINS for 1 TOKEN
     */
    uint128 private _ratio;

    /////////////////
    // Constructor //
    /////////////////
    constructor(
        address owner,
        Receiver[] receivers,
        address wallet,
        uint128 minDeposit,
        uint128 ratio,
        uint128 balance,
        address recipient
    ) accept reserveBalance(balance, recipient) receiversIsValid(receivers) {
        _owner = owner;
        _receivers = receivers;
        _wallet = wallet;
        _minDeposit = minDeposit;
        _ratio = ratio;
    }

    //////////////
    // External //
    //////////////
    // TODO remove hardcode
    function convert() public view {
        uint128 availableShare = address(this).balance - 1 ever - 0.1 ever;
        for (uint8 i = 0; i < _receivers.length; i++) {
            Receiver receiver = _receivers[i];
            uint128 value = math.muldiv(availableShare, receiver.share, SHARE_100_PERCENT);
            receiver.wallet.transfer(value, false, 1);
        }

        uint128 amount = math.muldiv(msg.value, RATIO_ONE_TO_ONE, _ratio);
        ITokenWallet(_wallet).transfer{ value: 400 milli, flag: 0, bounce: true }(
            amount,
            msg.sender,
            200 milli,
            address(this),
            false,
            TvmCell()
        );
    }

    ////////////////////////////
    // External // Only owner //
    ////////////////////////////
    function changeOwner(address owner) public onlyOwner giveChange {
        _owner = owner;
    }

    function changeRatio(uint128 ratio) public onlyOwner giveChange {
        _ratio = ratio;
    }

    function changeReceivers(Receiver[] receivers) public onlyOwner giveChange receiversIsValid(receivers) {
        _receivers = receivers;
    }

    function changeWallet(address wallet) public onlyOwner giveChange {
        _wallet = wallet;
    }

    function changeMinDeposit(uint128 minDeposit) public onlyOwner giveChange {
        _minDeposit = minDeposit;
    }

    function terminate(address destination) public view onlyOwner {
        destination.transfer(0, false, TRANSFER_ALL_REMAINING_BALANCE + DESTROY_IF_BALANCE_IS_ZERO);
    }

    // TODO drain
    // TODO withdraw tokens

    /////////////
    // Getters //
    /////////////
    function info() public view returns (
        address owner,
        Receiver[] receivers,
        address wallet,
        uint128 minDeposit,
        uint128 ratio
    ) {
        return (
            _owner,
            _receivers,
            _wallet,
            _minDeposit,
            _ratio
        );
    }
}
